/* Copyright 2012 Bernhard R. Fischer, 2048R/5C5FFD47 <bf@abenteuerland.at>
 *
 * This file is part of smrender.
 *
 * Smrender is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * Smrender is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with smrender. If not, see <http://www.gnu.org/licenses/>.
 */

/*! This file contains the code to generate the KAP file.
 *  Please note that this file contains two functions (bsb_compress_nb() and
 *  bsb_compress_row()) which are taken as is from the project libbsb
 *  (http://libbsb.sourceforge.net/). The authors of libbsb are Stuart
 *  Cunningham and Anuradha Suraparaju. Libbsb was released with LGPL.
 *
 *  @author Bernhard R. Fischer
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdint.h>
#include <errno.h>
#include <string.h>
#include <arpa/inet.h>

#include "smrender_dev.h"

#ifdef HAVE_CAIRO
#define get_pixel(x, y, z) cairo_smr_get_pixel(x, y, z)
#define get_image() cairo_smr_image_surface_from_bg(CAIRO_FORMAT_RGB24, CAIRO_ANTIALIAS_NONE)
#define destroy_image(x) cairo_surface_destroy(x)
int cairo_smr_image_surface_color_reduce(cairo_surface_t *, int , uint32_t *);
#else
#define get_pixel(x, y, z) 0
#define get_image() NULL
#define destroy_image(x) 0
#define cairo_smr_image_surface_color_reduce(x, y, z) 0
#endif


static uint16_t bsb_compress_nb(uint8_t *p, uint16_t nb, uint8_t pixel, uint16_t max)
{
    uint16_t count = 0;

    if (nb > max)
    {
        count = bsb_compress_nb(p,nb>>7,pixel|0x80,max);
        p[count++] = (nb & 0x7F) | (pixel & 0x80);
        return count;
    }
    pixel |= nb ;
    if (!pixel) p[count++] = 0x80;
    p[count++] = pixel ;
    return count;
}


static int bsb_compress_row(const uint8_t *buf_in, uint8_t *buf_out, uint16_t bits_out, uint16_t line, uint16_t widthin, uint16_t widthout)
{
   uint16_t ibuf,run_length ;
   uint16_t ipixelin,ipixelout,xout;
   uint8_t last_pix;
   uint16_t dec, max;

   dec = 7-bits_out;
   max = (1<<dec) -1;

   /*      write the line number */
   ibuf = bsb_compress_nb(buf_out,line,0,0x7F);

   ipixelin = ipixelout = 0;

   while ( ipixelin < widthin )
   {
      last_pix = buf_in[ipixelin];
      ipixelin++;
      ipixelout++;

      /* Count length of same pixel */
      run_length = 0;
      //if (ipixelin == 1592) ipixelin = 1592;
      while ( (ipixelin < widthin) && (buf_in[ipixelin] == last_pix) )
      {
         ipixelin++;
         ipixelout++;
         run_length++;
      }

      /* Extend, like but faster (total time/2) than xout = round((double)ipixelin*widthout/widthin); */
      xout = ((uint32_t)((ipixelin<<1)+1)*widthout)/((uint32_t)widthin<<1);
      if (xout > ipixelout)
      {
         run_length += xout - ipixelout;
         ipixelout = xout;
      }

      /* write pixel*/
      ibuf += bsb_compress_nb(buf_out+ibuf,run_length,last_pix<<dec,max);
   }
   buf_out[ibuf++] = 0;
   return ibuf;
}


static void strreplc(char *s)
{
   for (; *s != '\0'; s++)
      if (*s == ',')
         *s = ' ';
}


static int kap_fprint_ref(FILE *f, int ref, double x, double y)
{
   double lat, lon;

   pxf2geo(x, y, &lon, &lat);
   return fprintf(f, "REF/%d,%.0f,%.0f,%.8f,%.8f\r\n", ref, x, y, lat, lon);
}


static int kap_fprint_ply(FILE *f, int ref, double x, double y)
{
   double lat, lon;

   pxf2geo(x, y, &lon, &lat);
   return fprintf(f, "PLY/%d,%.8f,%.8f\r\n", ref, lat, lon);
}


int gen_kap_header(FILE *f, struct rdata *rd)
{
   double mppx;
   int off = 0;

   mppx = rd->mean_lat_len / rd->w * 1852.0 * 60.0;
   strreplc(rd->title);

   off += fprintf(f, "! generated by %s\r\n", PACKAGE_STRING);
   off += fprintf(f, "VER/2.0\r\nBSB/NA=%s %d\r\n    NU=,RA=%d,%d,DU=%d\r\n",
         rd->title, (int) round(rd->scale), (int) round(rd->w), (int) round(rd->h), rd->dpi);
   off += fprintf(f, "KNP/SC=%d,GD=WGS84,PR=MERCATOR\r\n    PP=%f,PI=UNKNOWN,SP=UNKNOWN,SK=0.0,TA=90.0\r\n",
         (int) round(rd->scale), rd->mean_lat);
   off += fprintf(f, "    UN=METRES,SD=MLWS,DX=%.2f,DY=%.2f\r\n",
         mppx, mppx);
   off += kap_fprint_ref(f, 1, 0, 0);
   off += kap_fprint_ref(f, 2, rd->w, rd->h);
   off += kap_fprint_ref(f, 3, 0, rd->h);
   off += kap_fprint_ply(f, 1, 0, 0);
   off += kap_fprint_ply(f, 2, rd->w, 0);
   off += kap_fprint_ply(f, 3, rd->w, rd->h);
   off += kap_fprint_ply(f, 4, 0, rd->h);
   off += fprintf(f, "DTM/0.0,0.0\r\nCPH/0.0\r\n");
   return off;
}


/*! Find index for a given color in the palette.
 * @param palette Pointer to palette.
 * @param cnt Number of colors in palette.
 * @param col Color to find.
 * @return Returns the index + 1 for the given color or -1 if the color was not
 * found.
 */
static int palette_index(uint32_t *palette, int cnt, uint32_t col)
{
   for (int i = 0; i < cnt; i++)
      if (col == palette[i])
         return i + 1;
   log_msg(LOG_ERR, "color #%06x not found in palette", col);
   return -1;
}


static int get_depth(int hcnt)
{
   int d, m;

   for (d = 1, m = 2; m < hcnt; m <<= 1, d++);
   return d;
}


int save_kap(FILE *f, struct rdata *rd)
{
   int d, i, x, y, hcnt, off, w = round(rd->w), h = round(rd->h);
   uint8_t buf_out[w + 4], buf_in[w];
   int32_t offp[h + 1];
   void *img;
   uint32_t palette[127];

   log_debug("writing KAP header");
   off = gen_kap_header(f, rd);

   img = get_image();
   log_debug("reducing colors");
   if ((hcnt = cairo_smr_image_surface_color_reduce(img, 127, palette)) <= 0)
   {
      log_msg(LOG_ERR, "reducing colors failed");
      return -1;
   }
   log_debug("reduced to %d colors", hcnt);

   d = get_depth(hcnt);
   log_debug("KAP color depth %d", d);
   off += fprintf(f, "OST/1\r\nIFM/%d\r\n", d);
   for (i = 0; i < hcnt; i++)
   {
      off += fprintf(f, "RGB/%d,%d,%d,%d\r\n", i + 1, (palette[i] >> 16) & 0xff, (palette[i] >> 8) & 0xff, palette[i] & 0xff);
      log_debug("palette[%d] = #%06x", i , palette[i]);
   }

   off += fprintf(f, "\x1a%c%c", '\0', (char) d);

   log_debug("compressing image");
   for (y = 0; y < h; y++)
   {
      if (!(y % (h / 10))) log_debug("compressing line %d", y);

      offp[y] = htonl(off);
      for (x = 0; x < w; x++)
         buf_in[x] = palette_index(palette, hcnt, get_pixel(img, x, y));
      i = bsb_compress_row(buf_in, buf_out, d, y, w, w);
      fwrite(buf_out, i, 1, f);
      off += i;
   }
   offp[y] = htonl(off);
   fwrite(offp, sizeof(int32_t), h + 1, f);
   
   destroy_image(img);

   return 0;
}

