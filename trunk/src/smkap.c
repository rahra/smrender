/* Copyright 2012 Bernhard R. Fischer, 2048R/5C5FFD47 <bf@abenteuerland.at>
 *
 * This file is part of smrender.
 *
 * Smrender is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3 of the License.
 *
 * Smrender is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with smrender. If not, see <http://www.gnu.org/licenses/>.
 */

/*! This file contains the code to generate the KAP file.
 *  Please note that this file contains two functions (bsb_compress_nb() and
 *  bsb_compress_row()) which are taken as is from the project libbsb
 *  (http://libbsb.sourceforge.net/). The authors of libbsb are Stuart
 *  Cunningham and Anuradha Suraparaju. Libbsb was released with LGPL.
 *
 *  @author Bernhard R. Fischer
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdint.h>
#include <errno.h>
#include <string.h>
#include <arpa/inet.h>

#include "smrender_dev.h"

#ifdef HAVE_CAIRO
#define get_pixel(x, y, z) cairo_smr_get_pixel(x, y, z)
#define get_image() cairo_smr_image_surface_from_bg()
#define destroy_image(x) cairo_surface_destroy(x)
#else
#define get_pixel(x, y, z) 0
#define get_image() NULL
#define destroy_image(x) 0
#endif


struct hist_data
{
   int col;
   int cnt;
};


static uint16_t bsb_compress_nb(uint8_t *p, uint16_t nb, uint8_t pixel, uint16_t max)
{
    uint16_t count = 0;

    if (nb > max)
    {
        count = bsb_compress_nb(p,nb>>7,pixel|0x80,max);
        p[count++] = (nb & 0x7F) | (pixel & 0x80);
        return count;
    }
    pixel |= nb ;
    if (!pixel) p[count++] = 0x80;
    p[count++] = pixel ;
    return count;
}


static int bsb_compress_row(const uint8_t *buf_in, uint8_t *buf_out, uint16_t bits_out, uint16_t line, uint16_t widthin, uint16_t widthout)
{
   uint16_t ibuf,run_length ;
   uint16_t ipixelin,ipixelout,xout;
   uint8_t last_pix;
   uint16_t dec, max;

   dec = 7-bits_out;
   max = (1<<dec) -1;

   /*      write the line number */
   ibuf = bsb_compress_nb(buf_out,line,0,0x7F);

   ipixelin = ipixelout = 0;

   while ( ipixelin < widthin )
   {
      last_pix = buf_in[ipixelin];
      ipixelin++;
      ipixelout++;

      /* Count length of same pixel */
      run_length = 0;
      //if (ipixelin == 1592) ipixelin = 1592;
      while ( (ipixelin < widthin) && (buf_in[ipixelin] == last_pix) )
      {
         ipixelin++;
         ipixelout++;
         run_length++;
      }

      /* Extend, like but faster (total time/2) than xout = round((double)ipixelin*widthout/widthin); */
      xout = ((uint32_t)((ipixelin<<1)+1)*widthout)/((uint32_t)widthin<<1);
      if (xout > ipixelout)
      {
         run_length += xout - ipixelout;
         ipixelout = xout;
      }

      /* write pixel*/
      ibuf += bsb_compress_nb(buf_out+ibuf,run_length,last_pix<<dec,max);
   }
   buf_out[ibuf++] = 0;
   return ibuf;
}


static void strreplc(char *s)
{
   for (; *s != '\0'; s++)
      if (*s == ',')
         *s = ' ';
}


static int kap_fprint_ref(FILE *f, int ref, double x, double y)
{
   double lat, lon;

   pxf2geo(x, y, &lon, &lat);
   return fprintf(f, "REF/%d,%.0f,%.0f,%.8f,%.8f\r\n", ref, x, y, lat, lon);
}


static int kap_fprint_ply(FILE *f, int ref, double x, double y)
{
   double lat, lon;

   pxf2geo(x, y, &lon, &lat);
   return fprintf(f, "PLY/%d,%.8f,%.8f\r\n", ref, lat, lon);
}


int gen_kap_header(FILE *f, struct rdata *rd)
{
   double mppx;
   int off = 0;

   mppx = rd->mean_lat_len / rd->fw * 1852.0 * 60.0;
   strreplc(rd->title);

   off += fprintf(f, "! generated by %s\r\n", PACKAGE_STRING);
   off += fprintf(f, "VER/2.0\r\nBSB/NA=%s %d\r\n    NU=,RA=%d,%d,DU=%d\r\n",
         rd->title, (int) round(rd->scale), rd->fw, rd->fh, rd->dpi);
   off += fprintf(f, "KNP/SC=%d,GD=WGS84,PR=MERCATOR\r\n    PP=%f,PI=UNKNOWN,SP=UNKNOWN,SK=0.0,TA=90.0\r\n",
         (int) round(rd->scale), rd->mean_lat);
   off += fprintf(f, "    UN=METRES,SD=MLWS,DX=%.2f,DY=%.2f\r\n",
         mppx, mppx);
   off += kap_fprint_ref(f, 1, 0, 0);
   off += kap_fprint_ref(f, 2, rd->fw, rd->fh);
   off += kap_fprint_ref(f, 3, 0, rd->fh);
   off += kap_fprint_ply(f, 1, 0, 0);
   off += kap_fprint_ply(f, 2, rd->fw, 0);
   off += kap_fprint_ply(f, 3, rd->fw, rd->fh);
   off += kap_fprint_ply(f, 4, 0, rd->fh);
   off += fprintf(f, "DTM/0.0,0.0\r\nCPH/0.0\r\n");
   return off;
}



static int cmp_hist(const void *h1, const void *h2)
{
   if (((struct hist_data*) h1)->cnt > ((struct hist_data*) h2)->cnt)
      return 1;
   if (((struct hist_data*) h1)->cnt < ((struct hist_data*) h2)->cnt)
      return -1;
   return 0;
}


static int gen_hist(struct rdata *rd, void *img, struct hist_data **hy)
{
   struct hist_data *hist = NULL;
   int hcnt = 0, i, x, y;

   log_debug("generating histogram");
   for (x = 0; x < rd->fw; x++)
   {
      for (y = 0; y < rd->fh; y++)
      {
         for (i = 0; i < hcnt; i++)
         {
            if (hist[i].col == (get_pixel(img, x, y) & 0xffffff))
            {
               hist[i].cnt++;
               break;
            }
         }
         if (i >= hcnt)
         {
            if ((hist = realloc(hist, (i + 1) * sizeof(*hist))) == NULL)
               log_msg(LOG_ERR, "cannot realloc in gen_hist(): %s", strerror(errno)),
                  exit(EXIT_FAILURE);
            hcnt++;
            hist[i].col = get_pixel(img, x, y) & 0xffffff;
            hist[i].cnt = 1;
            //log_debug("hist[%d].col = #%08x", i, hist[i].col);
         }
      }
   }

   log_debug("histogram has %d colors", hcnt);
   qsort(hist, hcnt, sizeof(*hist), cmp_hist);
   if (hcnt > 127)
   {
      hcnt = 127;
      log_debug("histogram reduced to %d colors", hcnt);
   }
   *hy = hist;
   return hcnt;
}


static int col_index(struct hist_data *hist, int hcnt, int col)
{
   long diff, delta;
   int i, j;

   for (i = 0, j = 0, diff = SQRL(0x1000000); i < hcnt; i++)
   {
      delta = col_cmp(col, hist[i].col);
      if (delta < diff)
      {
         j = i;
         diff = delta;
      }
      /*if (col >= hist[i].col && col <= hist[i + 1].col)
         return i + (col - hist[i].col > hist[i + 1].col - col);*/
   }
   return j + 1;
}


static int get_depth(int hcnt)
{
   int d, m;

   for (d = 1, m = 2; m < hcnt; m <<= 1, d++);
   return d;
}


int save_kap(FILE *f, struct rdata *rd)
{
   int d, i, x, y, hcnt, off, w = rd->fh;
   uint8_t buf_out[w + 4], buf_in[w];
   int32_t offp[rd->fh + 1];
   struct hist_data *hist;
   void *img;

   log_debug("writing KAP header");
   off = gen_kap_header(f, rd);

   img = get_image();
   hcnt = gen_hist(rd, img, &hist);
   d = get_depth(hcnt);
   log_debug("KAP color depth %d", d);
   off += fprintf(f, "OST/1\r\nIFM/%d\r\n", d);
   for (i = 0; i < hcnt; i++)
      off += fprintf(f, "RGB/%d,%d,%d,%d\r\n", i + 1, (hist[i].col >> 16) & 0xff, (hist[i].col >> 8) & 0xff, hist[i].col & 0xff);

   //fwrite("\x1a", 2, 1, f);
   off += fprintf(f, "\x1a%c%c", '\0', (char) d);

   log_debug("compressing image");
   for (y = 0; y < rd->fh; y++)
   {
      offp[y] = htonl(off);
      for (x = 0; x < rd->fw; x++)
         buf_in[x] = col_index(hist, hcnt, get_pixel(img, x, y) & 0xffffff);
      i = bsb_compress_row(buf_in, buf_out, d, y, rd->fw, rd->fw);
      fwrite(buf_out, i, 1, f);
      off += i;
   }
   offp[y] = htonl(off);
   fwrite(offp, sizeof(int32_t), rd->fh + 1, f);
   
   free(hist);
   destroy_image(img);

   return 0;
}

